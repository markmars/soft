------------------------
Re:网络游戏外挂编写教程（转载）

二：什么是封包？
怎么截获一个游戏的封包？
怎么去检查游戏服务器的ip地址和端口号？
   Internet用户使用的各种信息服务，其通讯的信息最终均可以归结为以IP包为单位的信息传送，IP包除了包括要传送的数据信息外，还包含有信息要发送到的目的IP地址、信息发送的源IP地址、以及一些相关的控制信息。当一台路由器收到一个IP数据包时，它将根据数据包中的目的IP地址项查找路由表，根据查找的结果将此IP数据包送往对应端口。下一台IP路由器收到此数据包后继续转发，直至发到目的地。路由器之间可以通过路由协议来进行路由信息的交换，从而更新路由表。

   那么我们所关心的内容只是IP包中的数据信息，我们可以使用许多监听网络的工具来截获客户端与服务器之间的交换数据，下面就向你介绍其中的一种工具：WPE。

WPE使用方法：
执行WPE会有下列几项功能可选择： 

SELECT GAME
选择目前在记忆体中您想拦截的程式，您只需双击该程式名称即可。

TRACE
追踪功能。用来追踪撷取程式送收的封包。
WPE必须先完成点选欲追踪的程式名称，才可以使用此项目。 
按下Play键开始撷取程式收送的封包。
您可以随时按下 | | 暂停追踪，想继续时请再按下 | | 。
按下正方形可以停止撷取封包并且显示所有已撷取封包内容。
若您没按下正方形停止键，追踪的动作将依照OPTION里的设定值自动停止。
如果您没有撷取到资料，试试将OPTION里调整为Winsock Version 2。
WPE 及 Trainers 是设定在显示至少16 bits 颜色下才可执行。

FILTER
过滤功能。用来分析所撷取到的封包，并且予以修改。

SEND PACKET
送出封包功能。能够让您送出假造的封包。

TRAINER MAKER
制作修改器。

OPTIONS
设定功能。让您调整WPE的一些设定值。

FILTER的详细教学


- 当FILTER在启动状态时 ，ON的按钮会呈现红色。
- 当您启动FILTER时，您随时可以关闭这个视窗。FILTER将会保留在原来的状态，直到您再按一次 on / off 钮。
- 只有FILTER启用钮在OFF的状态下，才可以勾选Filter前的方框来编辑修改。
- 当您想编辑某个Filter，只要双击该Filter的名字即可。

NORMAL MODE：


范例：

当您在 Street Fighter Online z快打旋风线上版{游戏中，您使用了两次火球而且击中了对方，这时您会撷取到以下的封包：
SEND-> 0000 08 14 21 06 01 04 
SEND-> 0000 02 09 87 00 67 FF A4 AA 11 22 00 00 00 00 
SEND-> 0000 03 84 11 09 11 09 
SEND-> 0000 0A 09 C1 10 00 00 FF 52 44 
SEND-> 0000 0A 09 C1 10 00 00 66 52 44 

您的第一个火球让对方减了16滴z16 = 10h{的生命值，
而您观察到第4跟第5个封包的位置4有10h的值出现，应该就是这里了。

您观察10h前的0A 09 C1在两个封包中都没改变，可见得这3个数值是发出火球的关键。

因此您将0A 09 C1 10填在搜寻列zSEARCH{，然后在修改列zMODIFY{的位置4填上FF。如此一来，当您再度发出火球时，FF会取代之前的10，也就是攻击力为255的火球了！

ADVANCED MODE：


范例：
   当您在一个游戏中，您不想要用真实姓名，您想用修改过的假名传送给对方。在您使用TRACE后，您会发现有些封包里面有您的名字出现。假设您的名字是Shadow，换算成16进位则是z53 68 61 64 6F 77{；而您打算用moonz6D 6F 6F 6E 20 20{来取代他。
1) SEND-> 0000 08 14 21 06 01 04
2) SEND-> 0000 01 06 99 53 68 61 64 6F 77 00 01 05 
3) SEND-> 0000 03 84 11 09 11 09
4) SEND-> 0000 0A 09 C1 10 00 53 68 61 64 6F 77 00 11 
5) SEND-> 0000 0A 09 C1 10 00 00 66 52 44 

但是您仔细看，您的名字在每个封包中并不是出现在相同的位置上

- 在第2个封包里，名字是出现在第4个位置上
- 在第4个封包里，名字是出现在第6个位置上

在这种情况下，您就需要使用ADVANCED MODE
- 您在搜寻列zSEARCH{填上：53 68 61 64 6F 77 z请务必从位置1开始填{
- 您想要从原来名字Shadow的第一个字母开始置换新名字，因此您要选择从数值被发现的位置开始替代连续数值z  the position of the chain found{。
- 现在，在修改列zMODIFY{000的位置填上：6D 6F 6F 6E 20 20 z此为相对应位置，也就是从原来搜寻栏的+001位置开始递换{
- 如果您想从封包的第一个位置就修改数值，请选择z  the beginning of the packet{

   了解一点TCP/IP协议常识的人都知道，互联网是将信息数据打包之后再传送出去的。每个数据包分为头部信息和数据信息两部分。头部信息包括数据包的发送地址和到达地址等。数据信息包括我们在游戏中相关操作的各项信息。那么在做截获封包的过程之前我们先要知道游戏服务器的IP地址和端口号等各种信息，实际上最简单的是看看我们游戏目录下，是否有一个SERVER.INI的配置文件，这个文件里你可以查看到个游戏服务器的IP地址，比如金庸群侠传就是如此，那么除了这个我们还可以在DOS下使用NETSTAT这个命令，

   NETSTAT命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。或者你可以使用木马客星等工具来查看网络连接。工具是很多的，看你喜欢用哪一种了。

NETSTAT命令的一般格式为：
NETSTAT [选项]

命令中各选项的含义如下：
-a 显示所有socket，包括正在监听的。
-c 每隔1秒就重新显示一遍，直到用户中断它。
-i 显示所有网络接口的信息。
-n 以网络IP地址代替名称，显示出网络连接情形。
-r 显示核心路由表，格式同"route -e"。
-t 显示TCP协议的连接情况。
-u 显示UDP协议的连接情况。
-v 显示正在进行的工作。



 
 注册: 2004-4    状态: Offline 2   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:25:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

三：怎么来分析我们截获的封包？
   首先我们将WPE截获的封包保存为文本文件，然后打开它，这时会看到如下的数据（这里我们以金庸群侠传里PK店小二客户端发送的数据为例来讲解）：

第一个文件：
SEND-> 0000 E6 56 0D 22 7E 6B E4 17 13 13 12 13 12 13 67 1B
SEND-> 0010 17 12 DD 34 12 12 12 12 17 12 0E 12 12 12 9B
SEND-> 0000 E6 56 1E F1 29 06 17 12 3B 0E 17 1A
SEND-> 0000 E6 56 1B C0 68 12 12 12 5A
SEND-> 0000 E6 56 02 C8 13 C9 7E 6B E4 17 10 35 27 13 12 12
SEND-> 0000 E6 56 17 C9 12

第二个文件：
SEND-> 0000 83 33 68 47 1B 0E 81 72 76 76 77 76 77 76 02 7E
SEND-> 0010 72 77 07 1C 77 77 77 77 72 77 72 77 77 77 6D
SEND-> 0000 83 33 7B 94 4C 63 72 77 5E 6B 72 F3
SEND-> 0000 83 33 7E A5 21 77 77 77 3F
SEND-> 0000 83 33 67 AD 76 CF 1B 0E 81 72 75 50 42 76 77 77
SEND-> 0000 83 33 72 AC 77

   我们发现两次PK店小二的数据格式一样，但是内容却不相同，我们是PK的同一个NPC，为什么会不同呢？
   原来金庸群侠传的封包是经过了加密运算才在网路上传输的，那么我们面临的问题就是如何将密文解密成明文再分析了。

   因为一般的数据包加密都是异或运算，所以这里先讲一下什么是异或。
   简单的说，异或就是"相同为0，不同为1"（这是针对二进制按位来讲的），举个例子，0001和0010异或，我们按位对比，得到异或结果是0011，计算的方法是：0001的第4位为0，0010的第4位为0，它们相同，则异或结果的第4位按照"相同为0，不同为1"的原则得到0，0001的第3位为0，0010的第3位为0，则异或结果的第3位得到0，0001的第2位为0，0010的第2位为1，则异或结果的第2位得到1，0001的第1位为1，0010的第1位为0，则异或结果的第1位得到1，组合起来就是0011。异或运算今后会遇到很多，大家可以先熟悉熟悉，熟练了对分析很有帮助的。

   下面我们继续看看上面的两个文件，按照常理，数据包的数据不会全部都有值的，游戏开发时会预留一些字节空间来便于日后的扩充，也就是说数据包里会存在一些"00"的字节，观察上面的文件，我们会发现文件一里很多"12"，文件二里很多"77"，那么这是不是代表我们说的"00"呢？推理到这里，我们就开始行动吧！

   我们把文件一与"12"异或，文件二与"77"异或，当然用手算很费事，我们使用"M2M 1.0 加密封包分析工具"来计算就方便多了。得到下面的结果：

第一个文件：
1 SEND-> 0000 F4 44 1F 30 6C 79 F6 05 01 01 00 01 00 01 75 09
 SEND-> 0010 05 00 CF 26 00 00 00 00 05 00 1C 00 00 00 89
2 SEND-> 0000 F4 44 0C E3 3B 13 05 00 29 1C 05 08
3 SEND-> 0000 F4 44 09 D2 7A 00 00 00 48
4 SEND-> 0000 F4 44 10 DA 01 DB 6C 79 F6 05 02 27 35 01 00 00
5 SEND-> 0000 F4 44 05 DB 00

第二个文件：
1 SEND-> 0000 F4 44 1F 30 6C 79 F6 05 01 01 00 01 00 01 75 09
 SEND-> 0010 05 00 70 6B 00 00 00 00 05 00 05 00 00 00 1A
2 SEND-> 0000 F4 44 0C E3 3B 13 05 00 29 1C 05 84
3 SEND-> 0000 F4 44 09 D2 56 00 00 00 48
4 SEND-> 0000 F4 44 10 DA 01 B8 6C 79 F6 05 02 27 35 01 00 00
5 SEND-> 0000 F4 44 05 DB 00

   哈，这一下两个文件大部分都一样啦，说明我们的推理是正确的，上面就是我们需要的明文！

   接下来就是搞清楚一些关键的字节所代表的含义，这就需要截获大量的数据来分析。

   首先我们会发现每个数据包都是"F4 44"开头，第3个字节是变化的，但是变化很有规律。我们来看看各个包的长度，发现什么没有？对了，第3个字节就是包的长度！
   通过截获大量的数据包，我们判断第4个字节代表指令，也就是说客户端告诉服务器进行的是什么操作。例如向服务器请求战斗指令为"30"，战斗中移动指令为"D4"等。
   接下来，我们就需要分析一下上面第一个包"F4 44 1F 30 6C 79 F6 05 01 01 00 01 00 01 75 09 05 00 CF 26 00 00 00 00 05 00 1C 00 00 00 89"，在这个包里包含什么信息呢？应该有通知服务器你PK的哪个NPC吧，我们就先来找找这个店小二的代码在什么地方。
   我们再PK一个小喽罗（就是大理客栈外的那个咯）：
SEND-> 0000 F4 44 1F 30 D4 75 F6 05 01 01 00 01 00 01 75 09
SEND-> 0010 05 00 8A 19 00 00 00 00 11 00 02 00 00 00 C0
   我们根据常理分析，游戏里的NPC种类虽然不会超过65535（FFFF），但开发时不会把自己限制在字的范围，那样不利于游戏的扩充，所以我们在双字里看看。通过"店小二"和"小喽罗"两个包的对比，我们把目标放在"6C 79 F6 05"和"CF 26 00 00"上。（对比一下很容易的，但你不能太迟钝咯，呵呵）我们再看看后面的包，在后面的包里应该还会出现NPC的代码，比如移动的包，游戏允许观战，服务器必然需要知道NPC的移动坐标，再广播给观战的其他玩家。在后面第4个包"SEND-> 0000 F4 44 10 DA 01 DB 6C 79 F6 05 02 27 35 01 00 00"里我们又看到了"6C 79 F6 05"，初步断定店小二的代码就是它了！
（这分析里边包含了很多工作的，大家可以用WPE截下数据来自己分析分析）

第一个包的分析暂时就到这里（里面还有的信息我们暂时不需要完全清楚了）

我们看看第4个包"SEND-> 0000 F4 44 10 DA 01 DB 6C 79 F6 05 02 27 35 01 00 00"，再截获PK黄狗的包，（狗会出来2只哦）看看包的格式：
SEND-> 0000 F4 44 1A DA 02 0B 4B 7D F6 05 02 27 35 01 00 00
SEND-> 0010 EB 03 F8 05 02 27 36 01 00 00

根据上面的分析，黄狗的代码为"4B 7D F6 05"（100040011），不过两只黄狗服务器怎样分辨呢？看看"EB 03 F8 05"（100140011），是上一个代码加上100000，呵呵，这样服务器就可以认出两只黄狗了。我们再通过野外遇敌截获的数据包来证实，果然如此。

   那么，这个包的格式应该比较清楚了：第3个字节为包的长度，"DA"为指令，第5个字节为NPC个数，从第7个字节开始的10个字节代表一个NPC的信息，多一个NPC就多10个字节来表示。

   大家如果玩过网金，必然知道随机遇敌有时会出现增援，我们就利用游戏这个增援来让每次战斗都会出现增援的NPC吧。

   通过在战斗中出现增援截获的数据包，我们会发现服务器端发送了这样一个包：
F4 44 12 E9 EB 03 F8 05 02 00 00 03 00 00 00 00 00 00 
第5-第8个字节为增援NPC的代码（这里我们就简单的以黄狗的代码来举例）。
   那么，我们就利用单机代理技术来同时欺骗客户端和服务器吧！

   好了，呼叫NPC的工作到这里算是完成了一小半，接下来的事情，怎样修改封包和发送封包，我们下节继续讲解吧。


 
 注册: 2004-4    状态: Offline 3   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:25:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

四：怎么冒充"客户端"向"服务器"发我们需要的封包？ 
   这里我们需要使用一个工具，它位于客户端和服务器端之间，它的工作就是进行数据包的接收和转发，这个工具我们称为代理。
如果代理的工作单纯就是接收和转发的话，这就毫无意义了，但是请注意：所有的数据包都要通过它来传输，这里的意义就重大了。我们可以分析接收到的数据包，或者直接转发，或者修改后转发，或者压住不转发，甚至伪造我们需要的封包来发送。

   下面我们继续讲怎样来同时欺骗服务器和客户端，也就是修改封包和伪造封包。
   通过我们上节的分析，我们已经知道了打多个NPC的封包格式，那么我们就动手吧！

   首先我们要查找客户端发送的包，找到战斗的特征，就是请求战斗的第1个包，我们找"F4 44 1F 30"这个特征，这是不会改变的，当然是要解密后来查找哦。
   找到后，表示客户端在向服务器请求战斗，我们不动这个包，转发。
   继续向下查找，这时需要查找的特征码不太好办，我们先查找"DA"，这是客户端发送NPC信息的数据包的指令，那么可能其他包也有"DA"，没关系，我们看前3个字节有没有"F4 44"就行了。找到后，我们的工作就开始了！

   我们确定要打的NPC数量。这个数量不能很大，原因在于网金的封包长度用一个字节表示，那么一个包可以有255个字节，我们上面分析过，增加一个NPC要增加10个字节，所以大家算算就知道，打20个NPC比较合适。

   然后我们要把客户端原来的NPC代码分析计算出来，因为增加的NPC代码要加上100000哦。再把我们增加的NPC代码计算出来，并且组合成新的封包，注意代表包长度的字节要修改啊，然后转发到服务器，这一步在编写程序的时候要注意算法，不要造成较大延迟。

   上面我们欺骗服务器端完成了，欺骗客户端就简单了，^-^

   发送了上面的封包后，我们根据新增NPC代码构造封包马上发给客户端，格式就是"F4 44 12 E9 NPC代码 02 00 00 03 00 00 00 00 00 00",把每个新增的NPC都构造这样一个包，按顺序连在一起发送给客户端，客户端也就被我们骗过了，很简单吧。

   以后战斗中其他的事我们就不管了，尽情地开打吧，呵呵。

   上面讲的需要一定的编程基础，但是不难，即使你不会编程，相信你继续看下去就会有收获了。



 
 注册: 2004-4    状态: Offline 4   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:25:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

六：如果单机代理被封，我们怎么利用底层的技术来接管游戏的发包？
     在WINDOWS系统中，网络通讯的任务是由一个叫WSOCK32.DLL(在SYSTEM目录下)来完成的，每当游戏被运行时,他都会自动的去调用这个动态连接库,因为在WINDOWS系统中对于文件的搜索顺序是 程序目录>系统目录>路径中设置的目录,所以我们就有机会替换掉系统的WSOCK32.DLL使的游戏调用我们的WSOCK32.DLL,这样我们就有了对于游戏封包绝对的控制权,有人问:"我们应该怎么做呢?",我们只要自己编写一个WSOCK32.DLL放到游戏的目录下,就OK了，当然让我们完全自己去编写一个WSOCK32.DLL是不太现实的,因为本身网络通讯要处理很多更底层的东西,比如说从网卡读取BIT流，所以我们选择由我们的WSOCK32.DLL去调用系统的WSOCK32.DLL来完成这个功能。

WSOCK32.DLL有很多的输出函数,函数如下:
__WSAFDIsSet
accept
AcceptEx
Arecv
Asend
bind
closesocket
closesockinfo
connect
dn_expand
EnumProtocolsA
EnumProtocolsW
GetAcceptExSockaddrs
GetAddressByNameA
GetAddressByNameW
gethostbyaddr
gethostbyname
gethostname
GetNameByTypeA
GetNameByTypeW
getnetbyname
getpeername
getprotobyname
getprotobynumber
getservbyname
getservbyport
GetServiceA
GetServiceW
getsockname
getsockopt
GetTypeByNameA
GetTypeByNameW
htonl
htons
inet_addr
inet_network
inet_ntoa
ioctlsocket
listen
MigrateWinsockConfiguration
NPLoadNameSpaces
NSPStartup
ntohl
ntohs
rcmd
recv
recv 
rexec
rresvport
s_perror
select
send
sendto
sethostname
SetServiceA
SetServiceW
setsockopt
shutdown
socket
TransmitFile
WEP
WSAAsyncGetHostByAddr
WSAAsyncGetHostByName
WSAAsyncGetProtoByName
WSAAsyncGetProtoByNumber
WSAAsyncGetServByName
WSAAsyncGetServByPort
WSAAsyncSelect
WSACancelAsyncRequest
WSACancelBlockingCall
WSACleanup
WSAGetLastError
WSAIsBlocking
WSApSetPostRoutine
WSARecvEx
WSASetBlockingHook
WSASetLastError
WSAStartup
WSAUnhookBlockingHook
WsControl
WSHEnumProtocols

   在这里,不是所有的函数都要修改,因为我们只关心发送和接收的封包,所以我们只要修改send 和recv两个函数，前者是发送封包的后者是接收封包的,我们在这两个函数的处理中加入我们自己的代码，来完成封包的辨认,修改以及转发等功能。


 
 注册: 2004-4    状态: Offline 5   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:26:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

六：如果单机代理被封，我们怎么利用底层的技术来接管游戏的发包？
     在WINDOWS系统中，网络通讯的任务是由一个叫WSOCK32.DLL(在SYSTEM目录下)来完成的，每当游戏被运行时,他都会自动的去调用这个动态连接库,因为在WINDOWS系统中对于文件的搜索顺序是 程序目录>系统目录>路径中设置的目录,所以我们就有机会替换掉系统的WSOCK32.DLL使的游戏调用我们的WSOCK32.DLL,这样我们就有了对于游戏封包绝对的控制权,有人问:"我们应该怎么做呢?",我们只要自己编写一个WSOCK32.DLL放到游戏的目录下,就OK了，当然让我们完全自己去编写一个WSOCK32.DLL是不太现实的,因为本身网络通讯要处理很多更底层的东西,比如说从网卡读取BIT流，所以我们选择由我们的WSOCK32.DLL去调用系统的WSOCK32.DLL来完成这个功能。

WSOCK32.DLL有很多的输出函数,函数如下:
__WSAFDIsSet
accept
AcceptEx
Arecv
Asend
bind
closesocket
closesockinfo
connect
dn_expand
EnumProtocolsA
EnumProtocolsW
GetAcceptExSockaddrs
GetAddressByNameA
GetAddressByNameW
gethostbyaddr
gethostbyname
gethostname
GetNameByTypeA
GetNameByTypeW
getnetbyname
getpeername
getprotobyname
getprotobynumber
getservbyname
getservbyport
GetServiceA
GetServiceW
getsockname
getsockopt
GetTypeByNameA
GetTypeByNameW
htonl
htons
inet_addr
inet_network
inet_ntoa
ioctlsocket
listen
MigrateWinsockConfiguration
NPLoadNameSpaces
NSPStartup
ntohl
ntohs
rcmd
recv
recv 
rexec
rresvport
s_perror
select
send
sendto
sethostname
SetServiceA
SetServiceW
setsockopt
shutdown
socket
TransmitFile
WEP
WSAAsyncGetHostByAddr
WSAAsyncGetHostByName
WSAAsyncGetProtoByName
WSAAsyncGetProtoByNumber
WSAAsyncGetServByName
WSAAsyncGetServByPort
WSAAsyncSelect
WSACancelAsyncRequest
WSACancelBlockingCall
WSACleanup
WSAGetLastError
WSAIsBlocking
WSApSetPostRoutine
WSARecvEx
WSASetBlockingHook
WSASetLastError
WSAStartup
WSAUnhookBlockingHook
WsControl
WSHEnumProtocols

   在这里,不是所有的函数都要修改,因为我们只关心发送和接收的封包,所以我们只要修改send 和recv两个函数，前者是发送封包的后者是接收封包的,我们在这两个函数的处理中加入我们自己的代码，来完成封包的辨认,修改以及转发等功能。


 
 注册: 2004-4    状态: Offline 6   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:26:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

七：怎么来分析客户端的有关资料？
   自己作外挂，大多时候要分析封包，不过因为有的功能是由客户端来辨别的，所以分析客户端的程序同样也很重要，分析客户端首先要求你能看懂汇编指令（只要"看懂"，要求很低的），其次是要能够熟练的运用一些工具，然后能剩下的也就是运气和游戏公司的漏洞了。（哈，不是每次都能成功的啊）下边我分步教给大家。

第一章 8086汇编指令

注：AX,BX,CX...,EAX,EBX,ECX...这些都是CPU用来存储数据的地方。

一、数据传输指令 
作用：它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 
1. 通用数据传送指令. 
  MOV 传送字或字节. 
  MOVSX 先符号扩展,再传送. 
  MOVZX 先零扩展,再传送. 
  PUSH 把字压入堆栈. 
  POP 把字弹出堆栈. 
  PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. 
  POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. 
  PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. 
  POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. 
  BSWAP 交换32位寄存器里字节的顺序 
  XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数) 
  CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX ) 
  XADD 先交换再累加.( 结果在第一个操作数里 ) 
  XLAT 字节查表转换. 
  BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]->AL ) 

2. 输入输出端口传送指令. 
  IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} ) 
  OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 ) 
  输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 

3. 目的地址传送指令. 
  LEA 装入有效地址. 
    例: LEA DX,string ;把偏移地址存到DX. 
  LDS 传送目标指针,把指针内容装入DS. 
    例: LDS SI,string ;把段地址:偏移地址存到DS:SI. 
  LES 传送目标指针,把指针内容装入ES. 
    例: LES DI,string ;把段地址:偏移地址存到ES:DI. 
  LFS 传送目标指针,把指针内容装入FS. 
    例: LFS DI,string ;把段地址:偏移地址存到FS:DI. 
  LGS 传送目标指针,把指针内容装入GS. 
    例: LGS DI,string ;把段地址:偏移地址存到GS:DI. 
  LSS 传送目标指针,把指针内容装入SS. 
    例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 

4. 标志传送指令. 
  LAHF 标志寄存器传送,把标志装入AH. 
  SAHF 标志寄存器传送,把AH内容装入标志寄存器. 
  PUSHF 标志入栈. 
  POPF 标志出栈. 
  PUSHD 32位标志入栈. 
  POPD 32位标志出栈. 

二、算术运算指令 
  ADD 加法. 
  ADC 带进位加法. 
  INC 加 1. 
  AAA 加法的ASCII码调整. 
  DAA 加法的十进制调整. 
  SUB 减法. 
  SBB 带借位减法. 
  DEC 减 1. 
  NEC 求反(以 0 减之). 
  CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). 
  AAS 减法的ASCII码调整. 
  DAS 减法的十进制调整. 
  MUL 无符号乘法. 
  IMUL 整数乘法. 
    以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算), 
  AAM 乘法的ASCII码调整. 
  DIV 无符号除法. 
  IDIV 整数除法. 
    以上两条,结果回送: 
    商回送AL,余数回送AH, (字节运算); 
    或 商回送AX,余数回送DX, (字运算). 
  AAD 除法的ASCII码调整. 
  CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) 
  CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) 
  CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) 
  CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) 

三、逻辑运算指令 
  AND 与运算. 
  OR 或运算. 
  XOR 异或运算. 
  NOT 取反. 
  TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). 
  SHL 逻辑左移. 
  SAL 算术左移.(=SHL) 
  SHR 逻辑右移. 
  SAR 算术右移.(=SHR) 
  ROL 循环左移. 
  ROR 循环右移. 
  RCL 通过进位的循环左移. 
  RCR 通过进位的循环右移. 
    以上八种移位指令,其移位次数可达255次. 
    移位一次时, 可直接用操作码. 如 SHL AX,1. 
    移位>1次时, 则由寄存器CL给出移位次数. 
     如 MOV CL,04 
        SHL AX,CL 

四、串指令 
  DS:SI 源串段寄存器 :源串变址. 
  ES:DI 目标串段寄存器:目标串变址. 
  CX 重复次数计数器. 
  AL/AX 扫描值. 
  D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. 
Z标志 用来控制扫描或比较操作的结束. 
  MOVS 串传送. 
  ( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) 
  CMPS 串比较. 
  ( CMPSB 比较字符. CMPSW 比较字. ) 
  SCAS 串扫描. 
    把AL或AX的内容与目标串作比较,比较结果反映在标志位. 
  LODS 装入串. 
    把源串中的元素(字或字节)逐一装入AL或AX中. 
  ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) 
  STOS 保存串. 
  是LODS的逆过程. 
  REP 当CX/ECX<>0时重复. 
  REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX<>0时重复. 
  REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX<>0时重复. 
  REPC 当CF=1且CX/ECX<>0时重复. 
  REPNC 当CF=0且CX/ECX<>0时重复.


 
 注册: 2004-4    状态: Offline 7   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:26:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

七：怎么来分析客户端的有关资料？
   自己作外挂，大多时候要分析封包，不过因为有的功能是由客户端来辨别的，所以分析客户端的程序同样也很重要，分析客户端首先要求你能看懂汇编指令（只要"看懂"，要求很低的），其次是要能够熟练的运用一些工具，然后能剩下的也就是运气和游戏公司的漏洞了。（哈，不是每次都能成功的啊）下边我分步教给大家。

第一章 8086汇编指令

注：AX,BX,CX...,EAX,EBX,ECX...这些都是CPU用来存储数据的地方。

一、数据传输指令 
作用：它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 
1. 通用数据传送指令. 
  MOV 传送字或字节. 
  MOVSX 先符号扩展,再传送. 
  MOVZX 先零扩展,再传送. 
  PUSH 把字压入堆栈. 
  POP 把字弹出堆栈. 
  PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. 
  POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. 
  PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. 
  POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. 
  BSWAP 交换32位寄存器里字节的顺序 
  XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数) 
  CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX ) 
  XADD 先交换再累加.( 结果在第一个操作数里 ) 
  XLAT 字节查表转换. 
  BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]->AL ) 

2. 输入输出端口传送指令. 
  IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} ) 
  OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 ) 
  输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 

3. 目的地址传送指令. 
  LEA 装入有效地址. 
    例: LEA DX,string ;把偏移地址存到DX. 
  LDS 传送目标指针,把指针内容装入DS. 
    例: LDS SI,string ;把段地址:偏移地址存到DS:SI. 
  LES 传送目标指针,把指针内容装入ES. 
    例: LES DI,string ;把段地址:偏移地址存到ES:DI. 
  LFS 传送目标指针,把指针内容装入FS. 
    例: LFS DI,string ;把段地址:偏移地址存到FS:DI. 
  LGS 传送目标指针,把指针内容装入GS. 
    例: LGS DI,string ;把段地址:偏移地址存到GS:DI. 
  LSS 传送目标指针,把指针内容装入SS. 
    例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 

4. 标志传送指令. 
  LAHF 标志寄存器传送,把标志装入AH. 
  SAHF 标志寄存器传送,把AH内容装入标志寄存器. 
  PUSHF 标志入栈. 
  POPF 标志出栈. 
  PUSHD 32位标志入栈. 
  POPD 32位标志出栈. 

二、算术运算指令 
  ADD 加法. 
  ADC 带进位加法. 
  INC 加 1. 
  AAA 加法的ASCII码调整. 
  DAA 加法的十进制调整. 
  SUB 减法. 
  SBB 带借位减法. 
  DEC 减 1. 
  NEC 求反(以 0 减之). 
  CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). 
  AAS 减法的ASCII码调整. 
  DAS 减法的十进制调整. 
  MUL 无符号乘法. 
  IMUL 整数乘法. 
    以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算), 
  AAM 乘法的ASCII码调整. 
  DIV 无符号除法. 
  IDIV 整数除法. 
    以上两条,结果回送: 
    商回送AL,余数回送AH, (字节运算); 
    或 商回送AX,余数回送DX, (字运算). 
  AAD 除法的ASCII码调整. 
  CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) 
  CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) 
  CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) 
  CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) 

三、逻辑运算指令 
  AND 与运算. 
  OR 或运算. 
  XOR 异或运算. 
  NOT 取反. 
  TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). 
  SHL 逻辑左移. 
  SAL 算术左移.(=SHL) 
  SHR 逻辑右移. 
  SAR 算术右移.(=SHR) 
  ROL 循环左移. 
  ROR 循环右移. 
  RCL 通过进位的循环左移. 
  RCR 通过进位的循环右移. 
    以上八种移位指令,其移位次数可达255次. 
    移位一次时, 可直接用操作码. 如 SHL AX,1. 
    移位>1次时, 则由寄存器CL给出移位次数. 
     如 MOV CL,04 
        SHL AX,CL 

四、串指令 
  DS:SI 源串段寄存器 :源串变址. 
  ES:DI 目标串段寄存器:目标串变址. 
  CX 重复次数计数器. 
  AL/AX 扫描值. 
  D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. 
Z标志 用来控制扫描或比较操作的结束. 
  MOVS 串传送. 
  ( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) 
  CMPS 串比较. 
  ( CMPSB 比较字符. CMPSW 比较字. ) 
  SCAS 串扫描. 
    把AL或AX的内容与目标串作比较,比较结果反映在标志位. 
  LODS 装入串. 
    把源串中的元素(字或字节)逐一装入AL或AX中. 
  ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) 
  STOS 保存串. 
  是LODS的逆过程. 
  REP 当CX/ECX<>0时重复. 
  REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX<>0时重复. 
  REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX<>0时重复. 
  REPC 当CF=1且CX/ECX<>0时重复. 
  REPNC 当CF=0且CX/ECX<>0时重复. 

五、程序转移指令 
1>无条件转移指令 (长转移) 
  JMP 无条件转移指令 
  CALL 过程调用 
  RET/RETF过程返回. 
2>条件转移指令 (短转移,-128到+127的距离内) 
  ( 当且仅当(SF XOR OF)=1时,OP1<OP2 ) 
  JA/JNBE 不小于或不等于时转移. 
  JAE/JNB 大于或等于转移. 
  JB/JNAE 小于转移. 
  JBE/JNA 小于或等于转移. 
  以上四条,测试无符号整数运算的结果(标志C和Z). 
  JG/JNLE 大于转移. 
  JGE/JNL 大于或等于转移. 
  JL/JNGE 小于转移. 
  JLE/JNG 小于或等于转移. 
  以上四条,测试带符号整数运算的结果(标志S,O和Z). 
  JE/JZ 等于转移. 
  JNE/JNZ 不等于时转移. 
  JC 有进位时转移. 
  JNC 无进位时转移. 
  JNO 不溢出时转移. 
  JNP/JPO 奇偶性为奇数时转移. 
  JNS 符号位为 "0" 时转移. 
  JO 溢出转移. 
  JP/JPE 奇偶性为偶数时转移. 
  JS 符号位为 "1" 时转移. 
3>循环控制指令(短转移) 
  LOOP CX不为零时循环. 
  LOOPE/LOOPZ CX不为零且标志Z=1时循环. 
  LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. 
  JCXZ CX为零时转移. 
  JECXZ ECX为零时转移. 
4>中断指令 
  INT 中断指令 
  INTO 溢出中断 
  IRET 中断返回 
5>处理器控制指令 
  HLT 处理器暂停, 直到出现中断或复位信号才继续. 
  WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. 
  ESC 转换到外处理器. 
  LOCK 封锁总线. 
  NOP 空操作. 
  STC 置进位标志位. 
  CLC 清进位标志位. 
  CMC 进位标志取反. 
  STD 置方向标志位. 
  CLD 清方向标志位. 
  STI 置中断允许位. 
  CLI 清中断允许位. 

六、伪指令 
  DW 定义字(2字节). 
  PROC 定义过程. 
  ENDP 过程结束. 
  SEGMENT 定义段. 
  ASSUME 建立段寄存器寻址. 
  ENDS 段结束. 
  END 程序结束. 

   当然不是所有的指令都能用的上的，我在这里全部写出来是为了让大家认识一下，方便大家以后的学习，我归纳了一下常用的指令，这些指令大家一定要熟练掌握才可以啊。

MOV 数据传送指令
PUSH,POP 堆栈指令
CMP 比较指令
LEA 取地址指令
XOR 异或指令
JE,JZ,JMP...(所有的转移指令)


 
 注册: 2004-4    状态: Offline 8   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:27:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

七：怎么来分析客户端的有关资料？
   自己作外挂，大多时候要分析封包，不过因为有的功能是由客户端来辨别的，所以分析客户端的程序同样也很重要，分析客户端首先要求你能看懂汇编指令（只要"看懂"，要求很低的），其次是要能够熟练的运用一些工具，然后能剩下的也就是运气和游戏公司的漏洞了。（哈，不是每次都能成功的啊）下边我分步教给大家。

第一章 8086汇编指令

注：AX,BX,CX...,EAX,EBX,ECX...这些都是CPU用来存储数据的地方。

一、数据传输指令 
作用：它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 
1. 通用数据传送指令. 
  MOV 传送字或字节. 
  MOVSX 先符号扩展,再传送. 
  MOVZX 先零扩展,再传送. 
  PUSH 把字压入堆栈. 
  POP 把字弹出堆栈. 
  PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. 
  POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. 
  PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. 
  POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. 
  BSWAP 交换32位寄存器里字节的顺序 
  XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数) 
  CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX ) 
  XADD 先交换再累加.( 结果在第一个操作数里 ) 
  XLAT 字节查表转换. 
  BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]->AL ) 

2. 输入输出端口传送指令. 
  IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} ) 
  OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 ) 
  输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 

3. 目的地址传送指令. 
  LEA 装入有效地址. 
    例: LEA DX,string ;把偏移地址存到DX. 
  LDS 传送目标指针,把指针内容装入DS. 
    例: LDS SI,string ;把段地址:偏移地址存到DS:SI. 
  LES 传送目标指针,把指针内容装入ES. 
    例: LES DI,string ;把段地址:偏移地址存到ES:DI. 
  LFS 传送目标指针,把指针内容装入FS. 
    例: LFS DI,string ;把段地址:偏移地址存到FS:DI. 
  LGS 传送目标指针,把指针内容装入GS. 
    例: LGS DI,string ;把段地址:偏移地址存到GS:DI. 
  LSS 传送目标指针,把指针内容装入SS. 
    例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 

4. 标志传送指令. 
  LAHF 标志寄存器传送,把标志装入AH. 
  SAHF 标志寄存器传送,把AH内容装入标志寄存器. 
  PUSHF 标志入栈. 
  POPF 标志出栈. 
  PUSHD 32位标志入栈. 
  POPD 32位标志出栈. 

二、算术运算指令 
  ADD 加法. 
  ADC 带进位加法. 
  INC 加 1. 
  AAA 加法的ASCII码调整. 
  DAA 加法的十进制调整. 
  SUB 减法. 
  SBB 带借位减法. 
  DEC 减 1. 
  NEC 求反(以 0 减之). 
  CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). 
  AAS 减法的ASCII码调整. 
  DAS 减法的十进制调整. 
  MUL 无符号乘法. 
  IMUL 整数乘法. 
    以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算), 
  AAM 乘法的ASCII码调整. 
  DIV 无符号除法. 
  IDIV 整数除法. 
    以上两条,结果回送: 
    商回送AL,余数回送AH, (字节运算); 
    或 商回送AX,余数回送DX, (字运算). 
  AAD 除法的ASCII码调整. 
  CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) 
  CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) 
  CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) 
  CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) 

三、逻辑运算指令 
  AND 与运算. 
  OR 或运算. 
  XOR 异或运算. 
  NOT 取反. 
  TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). 
  SHL 逻辑左移. 
  SAL 算术左移.(=SHL) 
  SHR 逻辑右移. 
  SAR 算术右移.(=SHR) 
  ROL 循环左移. 
  ROR 循环右移. 
  RCL 通过进位的循环左移. 
  RCR 通过进位的循环右移. 
    以上八种移位指令,其移位次数可达255次. 
    移位一次时, 可直接用操作码. 如 SHL AX,1. 
    移位>1次时, 则由寄存器CL给出移位次数. 
     如 MOV CL,04 
        SHL AX,CL 

四、串指令 
  DS:SI 源串段寄存器 :源串变址. 
  ES:DI 目标串段寄存器:目标串变址. 
  CX 重复次数计数器. 
  AL/AX 扫描值. 
  D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. 
Z标志 用来控制扫描或比较操作的结束. 
  MOVS 串传送. 
  ( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) 
  CMPS 串比较. 
  ( CMPSB 比较字符. CMPSW 比较字. ) 
  SCAS 串扫描. 
    把AL或AX的内容与目标串作比较,比较结果反映在标志位. 
  LODS 装入串. 
    把源串中的元素(字或字节)逐一装入AL或AX中. 
  ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) 
  STOS 保存串. 
  是LODS的逆过程. 
  REP 当CX/ECX<>0时重复. 
  REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX<>0时重复. 
  REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX<>0时重复. 
  REPC 当CF=1且CX/ECX<>0时重复. 
  REPNC 当CF=0且CX/ECX<>0时重复. 

五、程序转移指令 
1>无条件转移指令 (长转移) 
  JMP 无条件转移指令 
  CALL 过程调用 
  RET/RETF过程返回. 
2>条件转移指令 (短转移,-128到+127的距离内) 
  ( 当且仅当(SF XOR OF)=1时,OP1<OP2 ) 
  JA/JNBE 不小于或不等于时转移. 
  JAE/JNB 大于或等于转移. 
  JB/JNAE 小于转移. 
  JBE/JNA 小于或等于转移. 
  以上四条,测试无符号整数运算的结果(标志C和Z). 
  JG/JNLE 大于转移. 
  JGE/JNL 大于或等于转移. 
  JL/JNGE 小于转移. 
  JLE/JNG 小于或等于转移. 
  以上四条,测试带符号整数运算的结果(标志S,O和Z). 
  JE/JZ 等于转移. 
  JNE/JNZ 不等于时转移. 
  JC 有进位时转移. 
  JNC 无进位时转移. 
  JNO 不溢出时转移. 
  JNP/JPO 奇偶性为奇数时转移. 
  JNS 符号位为 "0" 时转移. 
  JO 溢出转移. 
  JP/JPE 奇偶性为偶数时转移. 
  JS 符号位为 "1" 时转移. 
3>循环控制指令(短转移) 
  LOOP CX不为零时循环. 
  LOOPE/LOOPZ CX不为零且标志Z=1时循环. 
  LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. 
  JCXZ CX为零时转移. 
  JECXZ ECX为零时转移. 
4>中断指令 
  INT 中断指令 
  INTO 溢出中断 
  IRET 中断返回 
5>处理器控制指令 
  HLT 处理器暂停, 直到出现中断或复位信号才继续. 
  WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. 
  ESC 转换到外处理器. 
  LOCK 封锁总线. 
  NOP 空操作. 
  STC 置进位标志位. 
  CLC 清进位标志位. 
  CMC 进位标志取反. 
  STD 置方向标志位. 
  CLD 清方向标志位. 
  STI 置中断允许位. 
  CLI 清中断允许位. 

六、伪指令 
  DW 定义字(2字节). 
  PROC 定义过程. 
  ENDP 过程结束. 
  SEGMENT 定义段. 
  ASSUME 建立段寄存器寻址. 
  ENDS 段结束. 
  END 程序结束. 

   当然不是所有的指令都能用的上的，我在这里全部写出来是为了让大家认识一下，方便大家以后的学习，我归纳了一下常用的指令，这些指令大家一定要熟练掌握才可以啊。

MOV 数据传送指令
PUSH,POP 堆栈指令
CMP 比较指令
LEA 取地址指令
XOR 异或指令
JE,JZ,JMP...(所有的转移指令)


 
 注册: 2004-4    状态: Offline 9   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:28:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

游戏外挂的编写原理（一）


【 编者言 】感谢VB365.COM的成员change为我们找到这篇文章，是有关自己编写一个网络游戏外挂的，希望对想自己写外挂的朋友有所帮助。

　一、 前言

　　所谓游戏外挂，其实是一种游戏外辅程序，它可以协助玩家自动产生游戏动作、修
改游戏网络数据包以及修改游

戏内存数据等，以实现玩家用最少的时间和金钱去完成功力升级和过关斩将。虽然，现
在对游戏外挂程序的“合法”

身份众说纷纭，在这里我不想对此发表任何个人意见，让时间去说明一切吧。

　　不管游戏外挂程序是不是“合法”身份，但是它却是具有一定的技术含量的，在这
些小小程序中使用了许多高端

技术，如拦截Sock技术、拦截API技术、模拟键盘与鼠标技术、直接修改程序内存技术
等等。本文将对常见的游戏外挂

中使用的技术进行全面剖析。

　　二、认识外挂

　　游戏外挂的历史可以追溯到单机版游戏时代，只不过当时它使用了另一个更通俗易
懂的名字??游戏修改器。它可

以在游戏中追踪锁定游戏主人公的各项能力数值。这样玩家在游戏中可以达到主角不掉
血、不耗费魔法、不消耗金钱

等目的。这样降低了游戏的难度，使得玩家更容易通关。

　　随着网络游戏的时代的来临，游戏外挂在原有的功能之上进行了新的发展，它变得
更加多种多样，功能更加强大

，操作更加简单，以至有些游戏的外挂已经成为一个体系，比如《石器时代》，外挂品
种达到了几十种，自动战斗、

自动行走、自动练级、自动补血、加速、不遇敌、原地遇敌、快速增加经验值、按键精
灵……几乎无所不包。

　　游戏外挂的设计主要是针对于某个游戏开发的，我们可以根据它针对的游戏的类型
可大致可将外挂分为两种大类

。

　　一类是将游戏中大量繁琐和无聊的攻击动作使用外挂自动完成，以帮助玩家轻松搞
定攻击对象并可以快速的增加

玩家的经验值。比如在《龙族》中有一种工作的设定，玩家的工作等级越高，就可以驾
驭越好的装备。但是增加工作

等级却不是一件有趣的事情，毋宁说是重复枯燥的机械劳动。如果你想做法师用的杖，
首先需要做基本工作--?砍树。

砍树的方法很简单，在一棵大树前不停的点鼠标就可以了，每10000的经验升一级。这
就意味着玩家要在大树前不停的

点击鼠标，这种无聊的事情通过"按键精灵"就可以解决。外挂的"按键精灵"功能可以让
玩家摆脱无趣的点击鼠标的工

作。

　　另一类是由外挂程序产生欺骗性的网络游戏封包，并将这些封包发送到网络游戏服
务器，利用这些虚假信息欺骗

服务器进行游戏数值的修改，达到修改角色能力数值的目的。这类外挂程序针对性很
强，一般在设计时都是针对某个

游戏某个版本来做的，因为每个网络游戏服务器与客户端交流的数据包各不相同，外挂
程序必须要对欺骗的网络游戏

服务器的数据包进行分析，才能产生服务器识别的数据包。这类外挂程序也是当前最流
利的一类游戏外挂程序。

　　另外，现在很多外挂程序功能强大，不仅实现了自动动作代理和封包功能，而且还
提供了对网络游戏的客户端程

序的数据进行修改，以达到欺骗网络游戏服务器的目的。我相信，随着网络游戏商家的
反外挂技术的进展，游戏外挂

将会产生更多更优秀的技术，让我们期待着看场技术大战吧......

　　三、外挂技术综述

　　可以将开发游戏外挂程序的过程大体上划分为两个部分：

　　前期部分工作是对外挂的主体游戏进行分析，不同类型的外挂分析主体游戏的内容
也不相同。如外挂为上述谈到

的外挂类型中的第一类时，其分析过程常是针对游戏的场景中的攻击对象的位置和分布
情况进行分析，以实现外挂自

动进行攻击以及位置移动。如外挂为外挂类型中的第二类时，其分析过程常是针对游戏
服务器与客户端之间通讯包数

据的结构、内容以及加密算法的分析。因网络游戏公司一般都不会公布其游戏产品的通
讯包数据的结构、内容和加密

算法的信息，所以对于开发第二类外挂成功的关键在于是否能正确分析游戏包数据的结
构、内容以及加密算法，虽然

可以使用一些工具辅助分析，但是这还是一种坚苦而复杂的工作。

　　后期部分工作主要是根据前期对游戏的分析结果，使用大量的程序开发技术编写外
挂程序以实现对游戏的控制或

修改。如外挂程序为第一类外挂时，通常会使用到鼠标模拟技术来实现游戏角色的自动
位置移动，使用键盘模拟技术

来实现游戏角色的自动攻击。如外挂程序为第二类外挂时，通常会使用到挡截Sock和挡
截API函数技术，以挡截游戏服

务器传来的网络数据包并将数据包修改后封包后传给游戏服务器。另外，还有许多外挂
使用对游戏客户端程序内存数

据修改技术以及游戏加速技术。

　　本文主要是针对开发游戏外挂程序后期使用的程序开发技术进行探讨，重点介绍的
如下几种在游戏外挂中常使用

的程序开发技术：

　　● 动作模拟技术：主要包括键盘模拟技术和鼠标模拟技术。

　　● 封包技术：主要包括挡截Sock技术和挡截API技术。


 
 注册: 2004-4    状态: Offline 10   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:28:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

游戏外挂的编写原理（二）


四、动作模拟技术

　　我们在前面介绍过，几乎所有的游戏都有大量繁琐和无聊的攻击动作以增加玩家的
功力，还有那些数不完的迷宫

，这些好像已经成为了角色游戏的代名词。现在，外挂可以帮助玩家从这些繁琐而无聊
的工作中摆脱出来，专注于游

戏情节的进展。外挂程序为了实现自动角色位置移动和自动攻击等功能，需要使用到键
盘模拟技术和鼠标模拟技术。

下面我们将重点介绍这些技术并编写一个简单的实例帮助读者理解动作模拟技术的实现
过程。

　　１． 鼠标模拟技术
　　
　　几乎所有的游戏中都使用了鼠标来改变角色的位置和方向，玩家仅用一个小小的鼠
标，就可以使角色畅游天下。

那么，我们如何实现在没有玩家的参与下角色也可以自动行走呢。其实实现这个并不
难，仅仅几个Windows API函数就

可以搞定，让我们先来认识认识这些API函数。

　　(1) 模拟鼠标动作API函数mouse_event，它可以实现模拟鼠标按下和放开等动作。

　　　　VOID mouse_event(
　　　　　　DWORD dwFlags, // 鼠标动作标识。
　　　　　　DWORD dx, // 鼠标水平方向位置。
　　　　　　DWORD dy, // 鼠标垂直方向位置。
　　　　　　DWORD dwData, // 鼠标轮子转动的数量。
　　　　　　DWORD dwExtraInfo // 一个关联鼠标动作辅加信息。
　　　　);

　　其中，dwFlags表示了各种各样的鼠标动作和点击活动，它的常用取值如下：

　　　MOUSEEVENTF_MOVE　表示模拟鼠标移动事件。

　　　MOUSEEVENTF_LEFTDOWN 表示模拟按下鼠标左键。

　　　MOUSEEVENTF_LEFTUP 表示模拟放开鼠标左键。

　　　MOUSEEVENTF_RIGHTDOWN 表示模拟按下鼠标右键。

　　　MOUSEEVENTF_RIGHTUP 表示模拟放开鼠标右键。

　　　MOUSEEVENTF_MIDDLEDOWN 表示模拟按下鼠标中键。

　　　MOUSEEVENTF_MIDDLEUP 表示模拟放开鼠标中键。

　　(2)、设置和获取当前鼠标位置的API函数。获取当前鼠标位置使用GetCursorPos()
函数，设置当前鼠标位置使用

SetCursorPos()函数。

　　　　BOOL GetCursorPos(
　　　　　LPPOINT　lpPoint // 返回鼠标的当前位置。
　　　　);
　　　　BOOL SetCursorPos(
　　　　int X, // 鼠标的水平方向位置。
　　　　　　int Y //鼠标的垂直方向位置。
　　　　);

　　通常游戏角色的行走都是通过鼠标移动至目的地，然后按一下鼠标的按钮就搞定
了。下面我们使用上面介绍的API

函数来模拟角色行走过程。

　　　CPoint oldPoint,newPoint;
　　　GetCursorPos(&oldPoint); //保存当前鼠标位置。
　　　newPoint.x = oldPoint.x+40;
　　　newPoint.y = oldPoint.y+10;
　　　SetCursorPos(newPoint.x,newPoint.y); //设置目的地位置。
　　　mouse_event(MOUSEEVENTF_RIGHTDOWN,0,0,0,0);//模拟按下鼠标右键。
　　　mouse_event(MOUSEEVENTF_RIGHTUP,0,0,0,0);//模拟放开鼠标右键。

　　2． 键盘模拟技术

　　在很多游戏中，不仅提供了鼠标的操作，而且还提供了键盘的操作，在对攻击对象
进行攻击时还可以使用快捷键

。为了使这些攻击过程能够自动进行，外挂程序需要使用键盘模拟技术。像鼠标模拟技
术一样，Windows API也提供了

一系列API函数来完成对键盘动作的模拟。

　　模拟键盘动作API函数keydb_event，它可以模拟对键盘上的某个或某些键进行按下
或放开的动作。

　　　VOID keybd_event(
　　　　　BYTE bVk, // 虚拟键值。
　　　　　BYTE bScan, // 硬件扫描码。
　　　　　DWORD dwFlags, // 动作标识。
　　　　　DWORD dwExtraInfo // 与键盘动作关联的辅加信息。
　　　);

　　其中，bVk表示虚拟键值，其实它是一个BYTE类型值的宏，其取值范围为1-254。有
关虚拟键值表请在MSDN上使用

关键字“Virtual-Key Codes”查找相关资料。bScan表示当键盘上某键被按下和放开
时，键盘系统硬件产生的扫描码

，我们可以MapVirtualKey()函数在虚拟键值与扫描码之间进行转换。dwFlags表示各种
各样的键盘动作，它有两种取

值：KEYEVENTF_EXTENDEDKEY和KEYEVENTF_KEYUP。

　　下面我们使用一段代码实现在游戏中按下Shift+R快捷键对攻击对象进行攻击。

　　　keybd_event(VK_CONTROL,MapVirtualKey(VK_CONTROL,0),0,0); //按下CTRL
键。
　　　keybd_event(0x52,MapVirtualKey(0x52,0),0,0);//键下R键。
　　　keybd_event(0x52,MapVirtualKey(0x52,0), KEYEVENTF_KEYUP,0);//放开R键。
　　　keybd_event(VK_CONTROL,MapVirtualKey(VK_CONTROL,0),
　　　KEYEVENTF_KEYUP,0);//放开CTRL键。

　　3． 激活外挂

　　上面介绍的鼠标和键盘模拟技术实现了对游戏角色的动作部分的模拟，但要想外挂
能工作于游戏之上，还需要将

其与游戏的场景窗口联系起来或者使用一个激活键，就象按键精灵的那个激活键一样。
我们可以用GetWindow函数来枚

举窗口，也可以用Findwindow函数来查找特定的窗口。另外还有一个FindWindowEx函数
可以找到窗口的子窗口，当游

戏切换场景的时候我们可以用FindWindowEx来确定一些当前窗口的特征，从而判断是否
还在这个场景，方法很多了，

比如可以GetWindowInfo来确定一些东西，比如当查找不到某个按钮的时候就说明游戏
场景已经切换了等等办法。当使

用激活键进行关联，需要使用Hook技术开发一个全局键盘钩子，在这里就不具体介绍全
局钩子的开发过程了，在后面

的实例中我们将会使用到全局钩子，到时将学习到全局钩子的相关知识。

4． 实例实现

　　通过上面的学习，我们已经基本具备了编写动作式游戏外挂的能力了。下面我们将
创建一个画笔程序外挂，它实

现自动移动画笔字光标的位置并写下一个红色的“R”字。以这个实例为基础，加入相
应的游戏动作规则，就可以实现

一个完整的游戏外挂。这里作者不想使用某个游戏作为例子来开发外挂（因没有游戏商
家的授权啊！），如读者感兴

趣的话可以找一个游戏试试，最好仅做测试技术用。

　　首先，我们需要编写一个全局钩子，使用它来激活外挂，激活键为F10。创建全局
钩子步骤如下：

　　(1)．选择MFC AppWizard(DLL)创建项目ActiveKey，并选择MFC Extension DLL
（共享MFC拷贝）类型。

　　(2).插入新文件ActiveKey.h，在其中输入如下代码：

　　　#ifndef _KEYDLL_H
　　　#define _KEYDLL_H

　　　class AFX_EXT_CLASS CKeyHook:public CObject
　　　{
　　　　public:
　CKeyHook();
　~CKeyHook();
　HHOOK Start();　//安装钩子
　BOOL Stop(); //卸载钩子
　　　};
　　　#endif

　　(3).在ActiveKey.cpp文件中加入声明＂#include ActiveKey.h＂。

　　(4).在ActiveKey.cpp文件中加入共享数据段，代码如下：

　　　//Shared data section
　　　#pragma data_seg("sharedata")
　　　HHOOK glhHook=NULL; //钩子句柄。
　　　HINSTANCE glhInstance=NULL; //DLL实例句柄。
　　　#pragma data_seg()

　　(5).在ActiveKey.def文件中设置共享数据段属性，代码如下：

　　　SETCTIONS
　　　shareddata READ WRITE SHARED

　　(6).在ActiveKey.cpp文件中加入CkeyHook类的实现代码和钩子函数代码：

　　　//键盘钩子处理函数。
　　　extern "C" LRESULT WINAPI KeyboardProc(int nCode,WPARAM wParam,LPARAM
lParam)
　　　{
　　　if( nCode >= 0 )
　　　{
　　　if( wParam == 0X79 )//当按下F10键时，激活外挂。
　{
　　//外挂实现代码。
CPoint newPoint,oldPoint;
　　 GetCursorPos(&oldPoint);
　　 newPoint.x = oldPoint.x+40;
　　 newPoint.y = oldPoint.y+10;
　　 SetCursorPos(newPoint.x,newPoint.y);
　　 mouse_event(MOUSEEVENTF_LEFTDOWN,0,0,0,0);//模拟按下鼠标左键。
　　mouse_event(MOUSEEVENTF_LEFTUP,0,0,0,0);//模拟放开鼠标左键。
　　keybd_event(VK_SHIFT,MapVirtualKey(VK_SHIFT,0),0,0); //按下SHIFT键。
　　keybd_event(0x52,MapVirtualKey(0x52,0),0,0);//按下R键。
　　keybd_event(0x52,MapVirtualKey(0x52,0),KEYEVENTF_KEYUP,0);//放开R键。
　　keybd_event(VK_SHIFT,MapVirtualKey(VK_SHIFT,0),KEYEVENTF_KEYUP,0);//放开
SHIFT键。
　　　　　　SetCursorPos(oldPoint.x,oldPoint.y);
　}
　　　}
　　　return CallNextHookEx(glhHook,nCode,wParam,lParam);
　　　}

　　　CKeyHook::CKeyHook(){}
　　　CKeyHook::~CKeyHook()
　　　{　
　　　if( glhHook )
Stop();
　　　}
　　　//安装全局钩子。
　　　HHOOK CKeyHook::Start()
　　　{
glhHook = SetWindowsHookEx(WH_KEYBOARD,KeyboardProc,glhInstance,0);//设置键
盘钩子。
return glhHook;
}
　　　//卸载全局钩子。
　　　BOOL CKeyHook::Stop()
　　　{
　　　BOOL bResult = TRUE;
　if( glhHook )
　　　bResult = UnhookWindowsHookEx(glhHook);//卸载键盘钩子。
　　　return bResult;
　　　}

　　(7).修改DllMain函数，代码如下：

　　　extern "C" int APIENTRY
　　　DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
　　　{
//如果使用lpReserved参数则删除下面这行
UNREFERENCED_PARAMETER(lpReserved);

if (dwReason == DLL_PROCESS_ATTACH)
{
　　TRACE0("NOtePadHOOK.DLL Initializing!\n");
　　 //扩展DLL仅初始化一次
　　if (!AfxInitExtensionModule(ActiveKeyDLL, hInstance))
return 0;
　　new CDynLinkLibrary(ActiveKeyDLL);
　　　　　　//把DLL加入动态MFC类库中
　　glhInstance = hInstance;
　　//插入保存DLL实例句柄
}
else if (dwReason == DLL_PROCESS_DETACH)
{
　　TRACE0("NotePadHOOK.DLL Terminating!\n");
　　//终止这个链接库前调用它
　　AfxTermExtensionModule(ActiveKeyDLL);
}
return 1;
　　　}

　　(8).编译项目ActiveKey，生成ActiveKey.DLL和ActiveKey.lib。

　　接着，我们还需要创建一个外壳程序将全局钩子安装了Windows系统中，这个外壳
程序编写步骤如下：

　　(1).创建一个对话框模式的应用程序，项目名为Simulate。

　　(2).在主对话框中加入一个按钮，使用ClassWizard为其创建CLICK事件。

　　(3).将ActiveKey项目Debug目录下的ActiveKey.DLL和ActiveKey.lib拷贝到
Simulate项目目录下。

　　(4).从“工程”菜单中选择“设置”，弹出Project Setting对话框，选择Link标
签，在“对象/库模块”中输入

ActiveKey.lib。
游戏外挂的编写原理（三）


(5).将ActiveKey项目中的ActiveKey.h头文件加入到Simulate项目中，并在
Stdafx.h中加入#include

ActiveKey.h。

　　(6).在按钮单击事件函数输入如下代码：

　　　void CSimulateDlg::OnButton1()
　　　{
// TODO: Add your control notification handler code here
if( !bSetup )
{
m_hook.Start();//激活全局钩子。
}
else
{
m_hook.Stop();//撤消全局钩子。
}
bSetup = !bSetup;

　　　}

　　(7).编译项目，并运行程序，单击按钮激活外挂。

　　(8).启动画笔程序，选择文本工具并将笔的颜色设置为红色，将鼠标放在任意位置
后，按F10键，画笔程序自动移

动鼠标并写下一个红色的大写R。图一展示了按F10键前的画笔程序的状态，图二展示了
按F10键后的画笔程序的状态。


 
 注册: 2004-4    状态: Offline 11   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:29:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

五、封包技术

　　通过对动作模拟技术的介绍，我们对游戏外挂有了一定程度上的认识，也学会了使
用动作模拟技术来实现简单的

动作模拟型游戏外挂的制作。这种动作模拟型游戏外挂有一定的局限性，它仅仅只能解
决使用计算机代替人力完成那

么有规律、繁琐而无聊的游戏动作。但是，随着网络游戏的盛行和复杂度的增加，很多
游戏要求将客户端动作信息及

时反馈回服务器，通过服务器对这些动作信息进行有效认证后，再向客户端发送下一步
游戏动作信息，这样动作模拟

技术将失去原有的效应。为了更好地“外挂”这些游戏，游戏外挂程序也进行了升级换
代，它们将以前针对游戏用户

界面层的模拟推进到数据通讯层，通过封包技术在客户端挡截游戏服务器发送来的游戏
控制数据包，分析数据包并修

改数据包；同时还需按照游戏数据包结构创建数据包，再模拟客户端发送给游戏服务
器，这个过程其实就是一个封包

的过程。

　　封包的技术是实现第二类游戏外挂的最核心的技术。封包技术涉及的知识很广泛，
实现方法也很多，如挡截

WinSock、挡截API函数、挡截消息、VxD驱动程序等。在此我们也不可能在此文中将所
有的封包技术都进行详细介绍，

故选择两种在游戏外挂程序中最常用的两种方法：挡截WinSock和挡截API函数。

　　1． 挡截WinSock

　　众所周知，Winsock是Windows网络编程接口，它工作于Windows应用层，它提供与
底层传输协议无关的高层数据传

输编程接口。在Windows系统中，使用WinSock接口为应用程序提供基于TCP/IP协议的网
络访问服务，这些服务是由

Wsock32.DLL动态链接库提供的函数库来完成的。

　　由上说明可知，任何Windows基于TCP/IP的应用程序都必须通过WinSock接口访问网
络，当然网络游戏程序也不例

外。由此我们可以想象一下，如果我们可以控制WinSock接口的话，那么控制游戏客户
端程序与服务器之间的数据包也

将易如反掌。按着这个思路，下面的工作就是如何完成控制WinSock接口了。由上面的
介绍可知，WinSock接口其实是

由一个动态链接库提供的一系列函数，由这些函数实现对网络的访问。有了这层的认
识，问题就好办多了，我们可以

制作一个类似的动态链接库来代替原WinSock接口库，在其中实现WinSock32.dll中实现
的所有函数，并保证所有函数

的参数个数和顺序、返回值类型都应与原库相同。在这个自制作的动态库中，可以对我
们感兴趣的函数（如发送、接

收等函数）进行挡截，放入外挂控制代码，最后还继续调用原WinSock库中提供的相应
功能函数，这样就可以实现对网

络数据包的挡截、修改和发送等封包功能。

　　下面重点介绍创建挡截WinSock外挂程序的基本步骤：

　　(1) 创建DLL项目，选择Win32 Dynamic-Link Library，再选择An empty DLL
project。

　　(2) 新建文件wsock32.h，按如下步骤输入代码：

　　① 加入相关变量声明：

　　　HMODULE hModule=NULL; //模块句柄
　　　char buffer[1000]; //缓冲区
　　　FARPROC proc; //函数入口指针

　　② 定义指向原WinSock库中的所有函数地址的指针变量，因WinSock库共提供70多
个函数，限于篇幅，在此就只选

择几个常用的函数列出，有关这些库函数的说明可参考MSDN相关内容。

　　　//定义指向原WinSock库函数地址的指针变量。
　　　SOCKET (__stdcall *socket1)(int ,int,int);//创建Sock函数。
　　　int　(__stdcall *WSAStartup1)(WORD,LPWSADATA);//初始化WinSock库函数。
　　　int　(__stdcall *WSACleanup1)();//清除WinSock库函数。
　　　int (__stdcall *recv1)(SOCKET ,char FAR * ,int ,int );//接收数据函数。
　　　int (__stdcall *send1)(SOCKET ,const char * ,int ,int);//发送数据函
数。
　　　int (__stdcall *connect1)(SOCKET,const struct sockaddr *,int);//创建连
接函数。
　　　int (__stdcall *bind1)(SOCKET ,const struct sockaddr *,int );//绑定函
数。
　　　......其它函数地址指针的定义略。

　　(3) 新建wsock32.cpp文件，按如下步骤输入代码：

　　① 加入相关头文件声明：

　　　#include <windows.h>
　　　#include <stdio.h>
　　　#include "wsock32.h"

　　② 添加DllMain函数，在此函数中首先需要加载原WinSock库，并获取此库中所有
函数的地址。代码如下：

　　　BOOL WINAPI DllMain (HANDLE hInst,ULONG ul_reason_for_call,LPVOID
lpReserved)
　　　{
　　　　if(hModule==NULL){
　　　　　//加载原WinSock库，原WinSock库已复制为wsock32.001。
　　　hModule=LoadLibrary("wsock32.001");
　　}
　　　　else return 1;
//获取原WinSock库中的所有函数的地址并保存，下面仅列出部分代码。
if(hModule!=NULL){
　　　　　//获取原WinSock库初始化函数的地址，并保存到WSAStartup1中。
proc=GetProcAddress(hModule,"WSAStartup");
　　　WSAStartup1=(int (_stdcall *)(WORD,LPWSADATA))proc;
　　　　　//获取原WinSock库消除函数的地址，并保存到WSACleanup1中。
　　　　proc=GetProcAddress(hModule i,"WSACleanup");
　　　　WSACleanup1=(int (_stdcall *)())proc;
　　　　　//获取原创建Sock函数的地址，并保存到socket1中。
　　　　proc=GetProcAddress(hModule,"socket");
　　　　　socket1=(SOCKET (_stdcall *)(int ,int,int))proc;
　　　　　//获取原创建连接函数的地址，并保存到connect1中。
　　　　　proc=GetProcAddress(hModule,"connect");
　　　　　connect1=(int (_stdcall *)(SOCKET ,const struct sockaddr
*,int ))proc;
　　　　　//获取原发送函数的地址，并保存到send1中。
　　　　　proc=GetProcAddress(hModule,"send");
　　　　　send1=(int (_stdcall *)(SOCKET ,const char * ,int ,int ))proc;
　　　　　//获取原接收函数的地址，并保存到recv1中。
　　　　　proc=GetProcAddress(hModule,"recv");
　　　　　recv1=(int (_stdcall *)(SOCKET ,char FAR * ,int ,int ))proc;
　　　　　......其它获取函数地址代码略。
　　　}
　　　else return 0;
　　　return 1;
}

　　③ 定义库输出函数，在此可以对我们感兴趣的函数中添加外挂控制代码，在所有
的输出函数的最后一步都调用原

WinSock库的同名函数。部分输出函数定义代码如下：

//库输出函数定义。
//WinSock初始化函数。
　　　　int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA
lpWSAData)
　　　　{
　　　　　//调用原WinSock库初始化函数
　　　　　return WSAStartup1(wVersionRequired,lpWSAData);
　　　　}
　　　　//WinSock结束清除函数。
　　　　int PASCAL FAR WSACleanup(void)
　　　　{
　　　　　return WSACleanup1(); //调用原WinSock库结束清除函数。
　　　　}
　　　　//创建Socket函数。
　　　　SOCKET PASCAL FAR socket (int af, int type, int protocol)
　　　　{
　　　　　//调用原WinSock库创建Socket函数。
　　　　　return socket1(af,type,protocol);
　　　　}
　　　　//发送数据包函数
　　　　int PASCAL FAR send(SOCKET s,const char * buf,int len,int flags)
　　　　{
　　　//在此可以对发送的缓冲buf的内容进行修改，以实现欺骗服务器。
　　　外挂代码......
　　　//调用原WinSock库发送数据包函数。
　　　　　return send1(s,buf,len,flags);
　　　　}
//接收数据包函数。
　　　　int PASCAL FAR recv(SOCKET s, char FAR * buf, int len, int flags)
　　　　{
　　　//在此可以挡截到服务器端发送到客户端的数据包，先将其保存到buffer中。
　　　strcpy(buffer,buf);
　　　//对buffer数据包数据进行分析后，对其按照玩家的指令进行相关修改。
　　　外挂代码......
　　　//最后调用原WinSock中的接收数据包函数。
　　　　　return recv1(s, buffer, len, flags);
　　　　　}
　　　　.......其它函数定义代码略。

　　(4)、新建wsock32.def配置文件，在其中加入所有库输出函数的声明，部分声明代
码如下：

　　　LIBRARY "wsock32"
　　　EXPORTS
　　　　WSAStartup @1
　　　WSACleanup @2
　　　　recv @3
　　　　send @4
　　　　socket @5
　　　bind @6
　　　closesocket @7
　　　connect @8

　　　......其它输出函数声明代码略。


 
 注册: 2004-4    状态: Offline 12   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:29:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

游戏外挂的编写原理（四）


(5)、从“工程”菜单中选择“设置”，弹出Project Setting对话框，选择Link标
签，在“对象/库模块”中输入

Ws2_32.lib。

　　(6)、编译项目，产生wsock32.dll库文件。

　　(7)、将系统目录下原wsock32.dll库文件拷贝到被外挂程序的目录下，并将其改名
为wsock.001；再将上面产生的

wsock32.dll文件同样拷贝到被外挂程序的目录下。重新启动游戏程序，此时游戏程序
将先加载我们自己制作的

wsock32.dll文件，再通过该库文件间接调用原WinSock接口函数来实现访问网络。上面
我们仅仅介绍了挡载WinSock的

实现过程，至于如何加入外挂控制代码，还需要外挂开发人员对游戏数据包结构、内
容、加密算法等方面的仔细分析

（这个过程将是一个艰辛的过程），再生成外挂控制代码。关于数据包分析方法和技
巧，不是本文讲解的范围，如您

感兴趣可以到网上查查相关资料。

2.挡截API

　　挡截API技术与挡截WinSock技术在原理上很相似，但是前者比后者提供了更强大的
功能。挡截WinSock仅只能挡截

WinSock接口函数，而挡截API可以实现对应用程序调用的包括WinSock API函数在内的
所有API函数的挡截。如果您的

外挂程序仅打算对WinSock的函数进行挡截的话，您可以只选择使用上小节介绍的挡截
WinSock技术。随着大量外挂程

序在功能上的扩展，它们不仅仅只提供对数据包的挡截，而且还对游戏程序中使用的
Windows API或其它DLL库函数的

挡截，以使外挂的功能更加强大。例如，可以通过挡截相关API函数以实现对非中文游
戏的汉化功能，有了这个利器，

可以使您的外挂程序无所不能了。

　　挡截API技术的原理核心也是使用我们自己的函数来替换掉Windows或其它DLL库提
供的函数，有点同挡截WinSock

原理相似吧。但是，其实现过程却比挡截WinSock要复杂的多，如像实现挡截Winsock过
程一样，将应用程序调用的所

有的库文件都写一个模拟库有点不大可能，就只说Windows API就有上千个，还有很多
库提供的函数结构并未公开，所

以写一个模拟库代替的方式不大现实，故我们必须另谋良方。

　　挡截API的最终目标是使用自定义的函数代替原函数。那么，我们首先应该知道应
用程序何时、何地、用何种方式

调用原函数。接下来，需要将应用程序中调用该原函数的指令代码进行修改，使它将调
用函数的指针指向我们自己定

义的函数地址。这样，外挂程序才能完全控制应用程序调用的API函数，至于在其中如
何加入外挂代码，就应需求而异

了。最后还有一个重要的问题要解决，如何将我们自定义的用来代替原API函数的函数
代码注入被外挂游戏程序进行地

址空间中，因在Windows系统中应用程序仅只能访问到本进程地址空间内的代码和数
据。

　　综上所述，要实现挡截API函数，至少需要解决如下三个问题：

　　● 如何定位游戏程序中调用API函数指令代码？

　　● 如何修改游戏程序中调用API函数指令代码？

　　● 如何将外挂代码（自定义的替换函数代码）注入到游戏程序进程地址空间？

　　下面我们逐一介绍这几个问题的解决方法：

　　(1) 、定位调用API函数指令代码

　　我们知道，在汇编语言中使用CALL指令来调用函数或过程的，它是通过指令参数中
的函数地址而定位到相应的函

数代码的。那么，我们如果能寻找到程序代码中所有调用被挡截的API函数的CALL指令
的话，就可以将该指令中的函数

地址参数修改为替代函数的地址。虽然这是一个可行的方案，但是实现起来会很繁琐，
也不稳健。庆幸的是，Windows

系统中所使用的可执行文件（PE格式）采用了输入地址表机制，将所有在程序调用的
API函数的地址信息存放在输入地

址表中，而在程序代码CALL指令中使用的地址不是API函数的地址，而是输入地址表中
该API函数的地址项，如想使程

序代码中调用的API函数被代替掉，只用将输入地址表中该API函数的地址项内容修改即
可。具体理解输入地址表运行

机制，还需要了解一下PE格式文件结构，其中图三列出了PE格式文件的大致结构。


　　图三：PE格式大致结构图(003.jpg)

　　PE格式文件一开始是一段DOS程序，当你的程序在不支持Windows的环境中运行时，
它就会显示“This Program

cannot be run in DOS mode”这样的警告语句，接着这个DOS文件头，就开始真正的PE
文件内容了。首先是一段称为

“IMAGE_NT_HEADER”的数据，其中是许多关于整个PE文件的消息，在这段数据的尾端
是一个称为Data Directory的数

据表，通过它能快速定位一些PE文件中段（section）的地址。在这段数据之后，则是
一个“IMAGE_SECTION_HEADER”

的列表，其中的每一项都详细描述了后面一个段的相关信息。接着它就是PE文件中最主
要的段数据了，执行代码、数

据和资源等等信息就分别存放在这些段中。

　　在所有的这些段里，有一个被称为“.idata”的段（输入数据段）值得我们去注
意，该段中包含着一些被称为输

入地址表（IAT，Import Address Table）的数据列表。每个用隐式方式加载的API所在
的DLL都有一个IAT与之对应，

同时一个API的地址也与IAT中一项相对应。当一个应用程序加载到内存中后，针对每一
个API函数调用，相应的产生如

下的汇编指令：

　　JMP DWORD PTR [XXXXXXXX]

　　或

　　CALL DWORD PTR [XXXXXXXX]

　　其中，[XXXXXXXX]表示指向了输入地址表中一个项，其内容是一个DWORD，而正是
这个DWORD才是API函数在内存中

的真正地址。因此我们要想拦截一个API的调用，只要简单的把那个DWORD改为我们自己
的函数的地址。

　　(2) 、修改调用API函数代码

　　从上面对PE文件格式的分析可知，修改调用API函数代码其实是修改被调用API函数
在输入地址表中IAT项内容。由

于Windows系统对应用程序指令代码地址空间的严密保护机制，使得修改程序指令代码
非常困难，以至于许多高手为之

编写VxD进入Ring0。在这里，我为大家介绍一种较为方便的方法修改进程内存，它仅需
要调用几个Windows核心API函

数，下面我首先来学会一下这几个API函数：

　　　DWORD VirtualQuery(
　　　LPCVOID lpAddress, // address of region
　　　PMEMORY_BASIC_INFORMATION lpBuffer, // information buffer
　　　DWORD dwLength // size of buffer
　　　);

　　该函数用于查询关于本进程内虚拟地址页的信息。其中，lpAddress表示被查询页
的区域地址；lpBuffer表示用于

保存查询页信息的缓冲；dwLength表示缓冲区大小。返回值为实际缓冲大小。

　　　BOOL VirtualProtect(
　　　LPVOID lpAddress, // region of committed pages
　　　SIZE_T dwSize, // size of the region
　　　DWORD flNewProtect, // desired access protection
　　　PDWORD lpflOldProtect // old protection
　　　);

　　该函数用于改变本进程内虚拟地址页的保护属性。其中，lpAddress表示被改变保
护属性页区域地址；dwSize表示

页区域大小；flNewProtect表示新的保护属性，可取值为PAGE_READONLY、
PAGE_READWRITE、PAGE_EXECUTE等；

lpflOldProtect表示用于保存改变前的保护属性。如果函数调用成功返回“T”，否则
返回“F”。

　　有了这两个API函数，我们就可以随心所欲的修改进程内存了。首先，调用
VirtualQuery()函数查询被修改内存的

页信息，再根据此信息调用VirtualProtect()函数改变这些页的保护属性为
PAGE_READWRITE，有了这个权限您就可以

任意修改进程内存数据了。下面一段代码演示了如何将进程虚拟地址为0x0040106c处的
字节清零。

　　　BYTE* pData = 0x0040106c;
　　　MEMORY_BASIC_INFORMATION mbi_thunk;
　　　//查询页信息。
　　　VirtualQuery(pData, &mbi_thunk, sizeof(MEMORY_BASIC_INFORMATION));
　　　//改变页保护属性为读写。
　　　VirtualProtect(mbi_thunk.BaseAddress,mbi_thunk.RegionSize,
　　　PAGE_READWRITE, &mbi_thunk.Protect);
　　　//清零。
　　　*pData = 0x00;
　　　//恢复页的原保护属性。
　　　DWORD dwOldProtect;
　　　VirtualProtect(mbi_thunk.BaseAddress,mbi_thunk.RegionSize,
　　　mbi_thunk.Protect, &dwOldProtect);
(3)、注入外挂代码进入被挂游戏进程中

　　完成了定位和修改程序中调用API函数代码后，我们就可以随意设计自定义的API函
数的替代函数了。做完这一切

后，还需要将这些代码注入到被外挂游戏程序进程内存空间中，不然游戏进程根本不会
访问到替代函数代码。注入方

法有很多，如利用全局钩子注入、利用注册表注入挡截User32库中的API函数、利用
CreateRemoteThread注入（仅限于

NT/2000）、利用BHO注入等。因为我们在动作模拟技术一节已经接触过全局钩子，我相
信聪明的读者已经完全掌握了

全局钩子的制作过程，所以我们在后面的实例中，将继续利用这个全局钩子。至于其它
几种注入方法，如果感兴趣可

参阅MSDN有关内容。

　　有了以上理论基础，我们下面就开始制作一个挡截MessageBoxA和recv函数的实
例，在开发游戏外挂程序 时，可

以此实例为框架，加入相应的替代函数和处理代码即可。此实例的开发过程如下：

　　(1) 打开前面创建的ActiveKey项目。

　　(2) 在ActiveKey.h文件中加入HOOKAPI结构，此结构用来存储被挡截API函数名
称、原API函数地址和替代函数地

址。

　　　typedef struct tag_HOOKAPI
　　　{
　　　LPCSTR szFunc;//被HOOK的API函数名称。
　　　PROC pNewProc;//替代函数地址。
　　　PROC pOldProc;//原API函数地址。
　　　}HOOKAPI, *LPHOOKAPI;

　　(3) 打开ActiveKey.cpp文件，首先加入一个函数，用于定位输入库在输入数据段
中的IAT地址。代码如下：

　　　extern "C" __declspec(dllexport)PIMAGE_IMPORT_DESCRIPTOR
　　　LocationIAT(HMODULE hModule, LPCSTR szImportMod)
　　　//其中，hModule为进程模块句柄；szImportMod为输入库名称。
　　　{
　　　//检查是否为DOS程序，如是返回NULL，因DOS程序没有IAT。
　　　PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER) hModule;
　　　if(pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE) return NULL;
　　　　//检查是否为NT标志，否则返回NULL。
　　　　PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDOSHeader+
(DWORD)(pDOSHeader-

>e_lfanew));
　　　　if(pNTHeader->Signature != IMAGE_NT_SIGNATURE) return NULL;
　　　　//没有IAT表则返回NULL。
　　　　
if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Vir
tualAddress == 0)

return NULL;
　　　　//定位第一个IAT位置。
　　　　PIMAGE_IMPORT_DESCRIPTOR pImportDesc =
(PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pDOSHeader + (DWORD)

(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Virtu
alAddress));
　　　　//根据输入库名称循环检查所有的IAT，如匹配则返回该IAT地址，否则检测下
一个IAT。
　　　　while (pImportDesc->Name)
　　　　{
　　　　　//获取该IAT描述的输入库名称。
　　　PSTR szCurrMod = (PSTR)((DWORD)pDOSHeader +
(DWORD)(pImportDesc->Name));
　　　if (stricmp(szCurrMod, szImportMod) == 0) break;
　　　pImportDesc++;
　　　　}
　　　　if(pImportDesc->Name == NULL) return NULL;
　　　return pImportDesc;
　　　}

　　再加入一个函数，用来定位被挡截API函数的IAT项并修改其内容为替代函数地址。
代码如下：

　　　extern "C" __declspec(dllexport)
　　　HookAPIByName( HMODULE hModule, LPCSTR szImportMod, LPHOOKAPI
pHookApi)
　　　//其中，hModule为进程模块句柄；szImportMod为输入库名称；pHookAPI为
HOOKAPI结构指针。
　　　{
　　　　//定位szImportMod输入库在输入数据段中的IAT地址。
　　　　PIMAGE_IMPORT_DESCRIPTOR pImportDesc = LocationIAT(hModule,
szImportMod);
　　if (pImportDesc == NULL) return FALSE;
　　　　//第一个Thunk地址。
　　　　PIMAGE_THUNK_DATA pOrigThunk = (PIMAGE_THUNK_DATA)((DWORD)hModule +
(DWORD)(pImportDesc-

>OriginalFirstThunk));
　　 //第一个IAT项的Thunk地址。
　　　　PIMAGE_THUNK_DATA pRealThunk = (PIMAGE_THUNK_DATA)((DWORD)hModule +
(DWORD)(pImportDesc-

>FirstThunk));
　　　　//循环查找被截API函数的IAT项，并使用替代函数地址修改其值。
　　　while(pOrigThunk->u1.Function)
{
　//检测此Thunk是否为IAT项。
if((pOrigThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) != IMAGE_ORDINAL_FLAG)
{
　 //获取此IAT项所描述的函数名称。
　PIMAGE_IMPORT_BY_NAME pByName
=(PIMAGE_IMPORT_BY_NAME)((DWORD)hModule+(DWORD)(pOrigThunk-

>u1.AddressOfData));
　if(pByName->Name[0] == \0) return FALSE;
　　//检测是否为挡截函数。
if(strcmpi(pHookApi->szFunc, (char*)pByName->Name) == 0)
　 {
　　　　　　　MEMORY_BASIC_INFORMATION mbi_thunk;
　　　　　　　//查询修改页的信息。
　　　　　　　VirtualQuery(pRealThunk, &mbi_thunk,
sizeof(MEMORY_BASIC_INFORMATION));
//改变修改页保护属性为PAGE_READWRITE。
　　　　　　　VirtualProtect(mbi_thunk.BaseAddress,mbi_thunk.RegionSize,
PAGE_READWRITE,

&mbi_thunk.Protect);
//保存原来的API函数地址。
　　　 　　if(pHookApi->pOldProc == NULL)
pHookApi->pOldProc = (PROC)pRealThunk->u1.Function;
　 //修改API函数IAT项内容为替代函数地址。
pRealThunk->u1.Function = (PDWORD)pHookApi->pNewProc;
//恢复修改页保护属性。
DWORD dwOldProtect;
　　　　　　　VirtualProtect(mbi_thunk.BaseAddress, mbi_thunk.RegionSize,
mbi_thunk.Protect,

&dwOldProtect);
　　　　　 }
}
　 pOrigThunk++;
　 pRealThunk++;
}
　　SetLastError(ERROR_SUCCESS); //设置错误为ERROR_SUCCESS，表示成功。
　　return TRUE;
　　　}

　　(4) 定义替代函数，此实例中只给MessageBoxA和recv两个API进行挡截。代码如下
：

　　　static int WINAPI MessageBoxA1 (HWND hWnd , LPCTSTR lpText, LPCTSTR
lpCaption, UINT uType)
　　　{
　　　　//过滤掉原MessageBoxA的正文和标题内容，只显示如下内容。
return MessageBox(hWnd, "Hook API OK!", "Hook API", uType);
　　　}
　　　static int WINAPI recv1(SOCKET s, char FAR *buf, int len, int flags )
　　　{
　　　//此处可以挡截游戏服务器发送来的网络数据包，可以加入分析和处理数据代
码。
　　　return recv(s,buf,len,flags);
　　　}

　　(5) 在KeyboardProc函数中加入激活挡截API代码，在if( wParam == 0X79 )语句
中后面加入如下else if语句：

　　　......
　　　//当激活F11键时，启动挡截API函数功能。
　　　else if( wParam == 0x7A )
　　　{
　　　　HOOKAPI api[2];
api[0].szFunc ="MessageBoxA";//设置被挡截函数的名称。
api[0].pNewProc = (PROC)MessageBoxA1;//设置替代函数的地址。
api[1].szFunc ="recv";//设置被挡截函数的名称。
api[1].pNewProc = (PROC)recv1; //设置替代函数的地址。
//设置挡截User32.dll库中的MessageBoxA函数。
HookAPIByName(GetModuleHandle(NULL),"User32.dll",&api[0]);
//设置挡截Wsock32.dll库中的recv函数。
HookAPIByName(GetModuleHandle(NULL),"Wsock32.dll",&api[1]);
　　　}
　　　......



(6) 在ActiveKey.cpp中加入头文件声明 "#include "wsock32.h"。 从“工程”菜
单中选择“设置”，弹出

Project Setting对话框，选择Link标签，在“对象/库模块”中输入Ws2_32..lib。

　　(7) 重新编译ActiveKey项目，产生ActiveKey.dll文件，将其拷贝到Simulate.exe
目录下。运行Simulate.exe并

启动全局钩子。激活任意应用程序，按F11键后，运行此程序中可能调用MessageBoxA函
数的操作，看看信息框是不是

有所变化。同样，如此程序正在接收网络数据包，就可以实现封包功能了。


 
 注册: 2004-4    状态: Offline 13   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:46:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

外挂涉及的技术很广泛，如果你不是疯子般痴迷的研究外挂，想编个外挂，很难。。。真的很难，但若能编出一个来，你就圆满了。

 
 注册: 2004-4    状态: Offline 14   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:50:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

当你外挂编写到一定程度，编个私服模拟客户端也未尝不可。

 
 注册: 2004-4    状态: Offline 15   Top 
 
livesky
Exp:46

战士
  发表于: 2004-4-28 20:51:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

说错了，是模拟服务器

 
 注册: 2004-4    状态: Offline 16   Top 
 
tyzam
Exp:42

战士
  发表于: 2004-4-29 8:57:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

经典阿，好像在哪看过


 
 注册: 2004-3    状态: Offline 17   Top 
 
humanai
Exp:20

论坛新成员
  发表于: 2004-4-29 18:22:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

顶

 
 注册: 2003-8    状态: Offline 18   Top 
 
xyz8848
Exp:58

战士
  发表于: 2004-4-30 3:13:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------
Re:网络游戏外挂编写教程（转载）

定义哈

 
 注册: 2004-4    状态: Offline 19   Top 
 
穆图
Exp:10

论坛新成员
  发表于: 2004-4-30 20:33:00 博客 | 档案 | Email | 短信 | 树状 | 收藏 | 编辑 | 删除 | 引用   
 

--------------------------------------------------------------------------------

 
